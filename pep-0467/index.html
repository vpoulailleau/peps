
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="color-scheme" content="light dark" />
    <title>PEP 467 – Minor API improvements for binary sequences | peps.python.org</title>
    <link rel="shortcut icon" href="../_static/py.png"/>
    <link rel="canonical" href="https://peps.python.org/pep-0467.html" />
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    <link rel="stylesheet" href="../_static/mq.css" type="text/css" />
    <link rel="stylesheet" href="../_static/dark.css" type="text/css" media="(prefers-color-scheme: dark)" id="css-dark"/>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" media="(prefers-color-scheme: light)" id="pyg" />
    <link rel="stylesheet" href="../_static/pygments_dark.css" type="text/css" media="(prefers-color-scheme: dark)" id="pyg-dark" />
    <link href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
    <meta name="description" content="Python Enhancement Proposals (PEPs)"/>
</head>
<body>
    <section id="pep-page-section">
        <header>
            <h1>Python Enhancement Proposals</h1>
            <ul class="breadcrumbs">
                <li><a href="https://www.python.org/" title="The Python Programming Language">Python</a> &raquo; </li>
                <li><a href="../pep-0000/">PEP Index</a> &raquo; </li>
                <li>PEP 467 – Minor API improvements for binary sequences</li>
            </ul>
            <button aria-label="Toggle dark mode" onClick="toggleColourScheme()"></button>
        </header>
        <article>
            <section id="pep-content">
<h1 class="page-title">PEP 467 – Minor API improvements for binary sequences</h1>
<dl class="rfc2822 field-list simple">
<dt class="field-odd">PEP</dt>
<dd class="field-odd">467</dd>
<dt class="field-even">Title</dt>
<dd class="field-even">Minor API improvements for binary sequences</dd>
<dt class="field-odd">Author</dt>
<dd class="field-odd">Nick Coghlan &lt;ncoghlan&#32;&#97;t&#32;gmail.com&gt;, Ethan Furman &lt;ethan&#32;&#97;t&#32;stoneleaf.us&gt;</dd>
<dt class="field-even">Status</dt>
<dd class="field-even">Draft</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd">Standards Track</dd>
<dt class="field-even">Created</dt>
<dd class="field-even">30-Mar-2014</dd>
<dt class="field-odd">Python-Version</dt>
<dd class="field-odd">3.11</dd>
<dt class="field-even">Post-History</dt>
<dd class="field-even">30-Mar-2014, 15-Aug-2014, 16-Aug-2014, 07-Jun-2016, 01-Sep-2016,
13-Apr-2021, 03-Nov-2021</dd>
</dl>
<hr class="docutils" />
<section id="contents">
<details><summary>Contents</summary><ul class="simple">
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#rationale">Rationale</a></li>
<li><a class="reference internal" href="#motivation">Motivation</a></li>
<li><a class="reference internal" href="#proposals">Proposals</a><ul>
<li><a class="reference internal" href="#addition-of-explicit-count-and-byte-initialised-sequence-constructors">Addition of explicit “count and byte initialised sequence” constructors</a></li>
<li><a class="reference internal" href="#addition-of-explicit-single-byte-constructors">Addition of explicit “single byte” constructors</a></li>
<li><a class="reference internal" href="#addition-of-ascii-constructors">Addition of “ascii” constructors</a></li>
<li><a class="reference internal" href="#addition-of-getbyte-method-to-retrieve-a-single-byte">Addition of “getbyte” method to retrieve a single byte</a></li>
<li><a class="reference internal" href="#addition-of-optimised-iterator-methods-that-produce-bytes-objects">Addition of optimised iterator methods that produce <code class="docutils literal notranslate"><span class="pre">bytes</span></code> objects</a></li>
</ul>
</li>
<li><a class="reference internal" href="#design-discussion">Design discussion</a><ul>
<li><a class="reference internal" href="#why-not-rely-on-sequence-repetition-to-create-zero-initialised-sequences">Why not rely on sequence repetition to create zero-initialised sequences?</a></li>
<li><a class="reference internal" href="#omitting-the-originally-proposed-builtin-function">Omitting the originally proposed builtin function</a></li>
<li><a class="reference internal" href="#scope-limitation-memoryview">Scope limitation: memoryview</a></li>
</ul>
</li>
<li><a class="reference internal" href="#references">References</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>
</details></section>
<section id="abstract">
<h2><a class="toc-backref" href="#abstract">Abstract</a></h2>
<p>This PEP proposes five small adjustments to the APIs of the <code class="docutils literal notranslate"><span class="pre">bytes</span></code> and
<code class="docutils literal notranslate"><span class="pre">bytearray</span></code> types to make it easier to operate entirely in the binary domain:</p>
<ul class="simple">
<li>Add <code class="docutils literal notranslate"><span class="pre">fromsize</span></code> alternative constructor</li>
<li>Add <code class="docutils literal notranslate"><span class="pre">fromint</span></code> alternative constructor</li>
<li>Add <code class="docutils literal notranslate"><span class="pre">ascii</span></code> alternative constructor</li>
<li>Add <code class="docutils literal notranslate"><span class="pre">getbyte</span></code> byte retrieval method</li>
<li>Add <code class="docutils literal notranslate"><span class="pre">iterbytes</span></code> alternative iterator</li>
</ul>
</section>
<section id="rationale">
<h2><a class="toc-backref" href="#rationale">Rationale</a></h2>
<p>During the initial development of the Python 3 language specification, the
core <code class="docutils literal notranslate"><span class="pre">bytes</span></code> type for arbitrary binary data started as the mutable type
that is now referred to as <code class="docutils literal notranslate"><span class="pre">bytearray</span></code>. Other aspects of operating in
the binary domain in Python have also evolved over the course of the Python
3 series, for example with <a class="pep reference internal" href="../pep-0461" title="PEP 461 – Adding % formatting to bytes and bytearray">PEP 461</a>.</p>
</section>
<section id="motivation">
<h2><a class="toc-backref" href="#motivation">Motivation</a></h2>
<p>With Python 3 and the split between <code class="docutils literal notranslate"><span class="pre">str</span></code> and <code class="docutils literal notranslate"><span class="pre">bytes</span></code>, one small but
important area of programming became slightly more difficult, and much more
painful – wire format protocols.</p>
<p>This area of programming is characterized by a mixture of binary data and
ASCII compatible segments of text (aka ASCII-encoded text).  The addition of
the new constructors, methods, and iterators will aid both in writing new
wire format code, and in porting any remaining Python 2 wire format code.</p>
<p>Common use-cases include <code class="docutils literal notranslate"><span class="pre">dbf</span></code> and <code class="docutils literal notranslate"><span class="pre">pdf</span></code> file formats, <code class="docutils literal notranslate"><span class="pre">email</span></code>
formats, and <code class="docutils literal notranslate"><span class="pre">FTP</span></code> and <code class="docutils literal notranslate"><span class="pre">HTTP</span></code> communications, among many others.</p>
</section>
<section id="proposals">
<h2><a class="toc-backref" href="#proposals">Proposals</a></h2>
<section id="addition-of-explicit-count-and-byte-initialised-sequence-constructors">
<h3><a class="toc-backref" href="#addition-of-explicit-count-and-byte-initialised-sequence-constructors">Addition of explicit “count and byte initialised sequence” constructors</a></h3>
<p>To replace the now discouraged behavior, this PEP proposes the addition of an
explicit <code class="docutils literal notranslate"><span class="pre">fromsize</span></code> alternative constructor as a class method on both
<code class="docutils literal notranslate"><span class="pre">bytes</span></code> and <code class="docutils literal notranslate"><span class="pre">bytearray</span></code> whose first argument is the count, and whose
second argument is the fill byte to use (defaults to <code class="docutils literal notranslate"><span class="pre">\x00</span></code>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">bytes</span><span class="o">.</span><span class="n">fromsize</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">b&#39;\x00\x00\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bytearray</span><span class="o">.</span><span class="n">fromsize</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">bytearray(b&#39;\x00\x00\x00&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bytes</span><span class="o">.</span><span class="n">fromsize</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x0a</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">b&#39;\x0a\x0a\x0a\x0a\x0a&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bytearray</span><span class="o">.</span><span class="n">fromsize</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x0a</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">bytearray(b&#39;\x0a\x0a\x0a\x0a\x0a&#39;)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">fromsize</span></code> will behave just as the current constructors behave when passed a
single integer, while allowing for non-zero fill values when needed.</p>
</section>
<section id="addition-of-explicit-single-byte-constructors">
<h3><a class="toc-backref" href="#addition-of-explicit-single-byte-constructors">Addition of explicit “single byte” constructors</a></h3>
<p>As binary counterparts to the text <code class="docutils literal notranslate"><span class="pre">chr</span></code> function, this PEP proposes
the addition of an explicit <code class="docutils literal notranslate"><span class="pre">fromint</span></code> alternative constructor as a class
method on both <code class="docutils literal notranslate"><span class="pre">bytes</span></code> and <code class="docutils literal notranslate"><span class="pre">bytearray</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">bytes</span><span class="o">.</span><span class="n">fromint</span><span class="p">(</span><span class="mi">65</span><span class="p">)</span>
<span class="go">b&#39;A&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bytearray</span><span class="o">.</span><span class="n">fromint</span><span class="p">(</span><span class="mi">65</span><span class="p">)</span>
<span class="go">bytearray(b&#39;A&#39;)</span>
</pre></div>
</div>
<p>These methods will only accept integers in the range 0 to 255 (inclusive):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">bytes</span><span class="o">.</span><span class="n">fromint</span><span class="p">(</span><span class="mi">512</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">integer must be in range(0, 256)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="nb">bytes</span><span class="o">.</span><span class="n">fromint</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">&#39;float&#39; object cannot be interpreted as an integer</span>
</pre></div>
</div>
<p>The documentation of the <code class="docutils literal notranslate"><span class="pre">ord</span></code> builtin will be updated to explicitly note
that <code class="docutils literal notranslate"><span class="pre">bytes.fromint</span></code> is the primary inverse operation for binary data, while
<code class="docutils literal notranslate"><span class="pre">chr</span></code> is the inverse operation for text data, and that <code class="docutils literal notranslate"><span class="pre">bytearray.fromint</span></code>
also exists.</p>
<p>Behaviorally, <code class="docutils literal notranslate"><span class="pre">bytes.fromint(x)</span></code> will be equivalent to the current
<code class="docutils literal notranslate"><span class="pre">bytes([x])</span></code> (and similarly for <code class="docutils literal notranslate"><span class="pre">bytearray</span></code>). The new spelling is
expected to be easier to discover and easier to read (especially when used
in conjunction with indexing operations on binary sequence types).</p>
<p>As a separate method, the new spelling will also work better with higher
order functions like <code class="docutils literal notranslate"><span class="pre">map</span></code>.</p>
<p>These new methods intentionally do NOT offer the same level of general integer
support as the existing <code class="docutils literal notranslate"><span class="pre">int.to_bytes</span></code> conversion method, which allows
arbitrarily large integers to be converted to arbitrarily long bytes objects. The
restriction to only accept positive integers that fit in a single byte means
that no byte order information is needed, and there is no need to handle
negative numbers. The documentation of the new methods will refer readers to
<code class="docutils literal notranslate"><span class="pre">int.to_bytes</span></code> for use cases where handling of arbitrary integers is needed.</p>
</section>
<section id="addition-of-ascii-constructors">
<h3><a class="toc-backref" href="#addition-of-ascii-constructors">Addition of “ascii” constructors</a></h3>
<p>In Python 2 converting an object, such as the integer <code class="docutils literal notranslate"><span class="pre">123</span></code>, to bytes (aka the
Python 2 <code class="docutils literal notranslate"><span class="pre">str</span></code>) was as simple as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="mi">123</span><span class="p">)</span>
<span class="go">&#39;123&#39;</span>
</pre></div>
</div>
<p>With Python 3 that became the more verbose:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="mi">123</span>
</pre></div>
</div>
<p>or even:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="mi">123</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>This PEP proposes that an <code class="docutils literal notranslate"><span class="pre">ascii</span></code> method be added to <code class="docutils literal notranslate"><span class="pre">bytes</span></code> and <code class="docutils literal notranslate"><span class="pre">bytearray</span></code>
to handle this use-case:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">bytes</span><span class="o">.</span><span class="n">ascii</span><span class="p">(</span><span class="mi">123</span><span class="p">)</span>
<span class="go">b&#39;123&#39;</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">bytes.ascii()</span></code> would handle simple ascii-encodable text correctly,
unlike the <code class="docutils literal notranslate"><span class="pre">ascii()</span></code> built-in:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ascii</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">)</span>
<span class="go">b&quot;&#39;hello&#39;&quot;</span>
</pre></div>
</div>
</section>
<section id="addition-of-getbyte-method-to-retrieve-a-single-byte">
<h3><a class="toc-backref" href="#addition-of-getbyte-method-to-retrieve-a-single-byte">Addition of “getbyte” method to retrieve a single byte</a></h3>
<p>This PEP proposes that <code class="docutils literal notranslate"><span class="pre">bytes</span></code> and <code class="docutils literal notranslate"><span class="pre">bytearray</span></code> gain the method <code class="docutils literal notranslate"><span class="pre">getbyte</span></code>
which will always return <code class="docutils literal notranslate"><span class="pre">bytes</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;abc&#39;</span><span class="o">.</span><span class="n">getbyte</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">b&#39;a&#39;</span>
</pre></div>
</div>
<p>If an index is asked for that doesn’t exist, <code class="docutils literal notranslate"><span class="pre">IndexError</span></code> is raised:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;abc&#39;</span><span class="o">.</span><span class="n">getbyte</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">IndexError</span>: <span class="n">index out of range</span>
</pre></div>
</div>
</section>
<section id="addition-of-optimised-iterator-methods-that-produce-bytes-objects">
<h3><a class="toc-backref" href="#addition-of-optimised-iterator-methods-that-produce-bytes-objects">Addition of optimised iterator methods that produce <code class="docutils literal notranslate"><span class="pre">bytes</span></code> objects</a></h3>
<p>This PEP proposes that <code class="docutils literal notranslate"><span class="pre">bytes</span></code> and <code class="docutils literal notranslate"><span class="pre">bytearray</span></code> gain an optimised
<code class="docutils literal notranslate"><span class="pre">iterbytes</span></code> method that produces length 1 <code class="docutils literal notranslate"><span class="pre">bytes</span></code> objects rather than
integers:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">iterbytes</span><span class="p">():</span>
    <span class="c1"># x is a length 1 ``bytes`` object, rather than an integer</span>
</pre></div>
</div>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">tuple</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;ABC&quot;</span><span class="o">.</span><span class="n">iterbytes</span><span class="p">())</span>
<span class="go">(b&#39;A&#39;, b&#39;B&#39;, b&#39;C&#39;)</span>
</pre></div>
</div>
</section>
</section>
<section id="design-discussion">
<h2><a class="toc-backref" href="#design-discussion">Design discussion</a></h2>
<section id="why-not-rely-on-sequence-repetition-to-create-zero-initialised-sequences">
<h3><a class="toc-backref" href="#why-not-rely-on-sequence-repetition-to-create-zero-initialised-sequences">Why not rely on sequence repetition to create zero-initialised sequences?</a></h3>
<p>Zero-initialised sequences can be created via sequence repetition:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x00</span><span class="s1">&#39;</span> <span class="o">*</span> <span class="mi">3</span>
<span class="go">b&#39;\x00\x00\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bytearray</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x00</span><span class="s1">&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span>
<span class="go">bytearray(b&#39;\x00\x00\x00&#39;)</span>
</pre></div>
</div>
<p>However, this was also the case when the <code class="docutils literal notranslate"><span class="pre">bytearray</span></code> type was originally
designed, and the decision was made to add explicit support for it in the
type constructor. The immutable <code class="docutils literal notranslate"><span class="pre">bytes</span></code> type then inherited that feature
when it was introduced in <a class="pep reference internal" href="../pep-3137" title="PEP 3137 – Immutable Bytes and Mutable Buffer">PEP 3137</a>.</p>
<p>This PEP isn’t revisiting that original design decision, just changing the
spelling as users sometimes find the current behavior of the binary sequence
constructors surprising. In particular, there’s a reasonable case to be made
that <code class="docutils literal notranslate"><span class="pre">bytes(x)</span></code> (where <code class="docutils literal notranslate"><span class="pre">x</span></code> is an integer) should behave like the
<code class="docutils literal notranslate"><span class="pre">bytes.fromint(x)</span></code> proposal in this PEP. Providing both behaviors as separate
class methods avoids that ambiguity.</p>
</section>
<section id="omitting-the-originally-proposed-builtin-function">
<h3><a class="toc-backref" href="#omitting-the-originally-proposed-builtin-function">Omitting the originally proposed builtin function</a></h3>
<p>When submitted to the Steering Council, this PEP proposed the introduction of
a <code class="docutils literal notranslate"><span class="pre">bchr</span></code> builtin (with the same behaviour as <code class="docutils literal notranslate"><span class="pre">bytes.fromint</span></code>), recreating
the <code class="docutils literal notranslate"><span class="pre">ord</span></code>/<code class="docutils literal notranslate"><span class="pre">chr</span></code>/<code class="docutils literal notranslate"><span class="pre">unichr</span></code> trio from Python 2 under a different naming
scheme (<code class="docutils literal notranslate"><span class="pre">ord</span></code>/<code class="docutils literal notranslate"><span class="pre">bchr</span></code>/<code class="docutils literal notranslate"><span class="pre">chr</span></code>).</p>
<p>The SC indicated they didn’t think this functionality was needed often enough
to justify offering two ways of doing the same thing, especially when one of
those ways was a new builtin function. That part of the proposal was therefore
dropped as being redundant with the <code class="docutils literal notranslate"><span class="pre">bytes.fromint</span></code> alternate constructor.</p>
<p>Developers that use this method frequently will instead have the option to
define their own <code class="docutils literal notranslate"><span class="pre">bchr</span> <span class="pre">=</span> <span class="pre">bytes.fromint</span></code> aliases.</p>
</section>
<section id="scope-limitation-memoryview">
<h3><a class="toc-backref" href="#scope-limitation-memoryview">Scope limitation: memoryview</a></h3>
<p>Updating <code class="docutils literal notranslate"><span class="pre">memoryview</span></code> with the new item retrieval methods is outside the scope
of this PEP.</p>
</section>
</section>
<section id="references">
<h2><a class="toc-backref" href="#references">References</a></h2>
<dl class="footnote brackets">
<dt class="label" id="id1">[1]</dt>
<dd>Initial March 2014 discussion thread on python-ideas
(<a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2014-March/027295.html">https://mail.python.org/pipermail/python-ideas/2014-March/027295.html</a>)</dd>
<dt class="label" id="id2">[2]</dt>
<dd>Guido’s initial feedback in that thread
(<a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2014-March/027376.html">https://mail.python.org/pipermail/python-ideas/2014-March/027376.html</a>)</dd>
<dt class="label" id="id3">[3]</dt>
<dd>Issue proposing moving zero-initialised sequences to a dedicated API
(<a class="reference external" href="http://bugs.python.org/issue20895">http://bugs.python.org/issue20895</a>)</dd>
<dt class="label" id="id4">[4]</dt>
<dd>Issue proposing to use calloc() for zero-initialised binary sequences
(<a class="reference external" href="http://bugs.python.org/issue21644">http://bugs.python.org/issue21644</a>)</dd>
<dt class="label" id="id5">[5]</dt>
<dd>August 2014 discussion thread on python-dev
(<a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2014-March/027295.html">https://mail.python.org/pipermail/python-ideas/2014-March/027295.html</a>)</dd>
<dt class="label" id="id6">[6]</dt>
<dd>June 2016 discussion thread on python-dev
(<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2016-June/144875.html">https://mail.python.org/pipermail/python-dev/2016-June/144875.html</a>)</dd>
</dl>
</section>
<section id="copyright">
<h2><a class="toc-backref" href="#copyright">Copyright</a></h2>
<p>This document has been placed in the public domain.</p>
</section>
</section>
<hr class="docutils" />
<p>Source: <a class="reference external" href="https://github.com/python/peps/blob/main/pep-0467.txt">https://github.com/python/peps/blob/main/pep-0467.txt</a></p>
<p>Last modified: <a class="reference external" href="https://github.com/python/peps/commits/main/pep-0467.txt">2022-03-09 16:04:44 GMT</a></p>

        </article>
        <nav id="pep-sidebar">
            <h2>Contents</h2>
            <p id="toc-title">PEP 467 – Minor API improvements for binary sequences</p>
            <ul>
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#rationale">Rationale</a></li>
<li><a class="reference internal" href="#motivation">Motivation</a></li>
<li><a class="reference internal" href="#proposals">Proposals</a><ul>
<li><a class="reference internal" href="#addition-of-explicit-count-and-byte-initialised-sequence-constructors">Addition of explicit “count and byte initialised sequence” constructors</a></li>
<li><a class="reference internal" href="#addition-of-explicit-single-byte-constructors">Addition of explicit “single byte” constructors</a></li>
<li><a class="reference internal" href="#addition-of-ascii-constructors">Addition of “ascii” constructors</a></li>
<li><a class="reference internal" href="#addition-of-getbyte-method-to-retrieve-a-single-byte">Addition of “getbyte” method to retrieve a single byte</a></li>
<li><a class="reference internal" href="#addition-of-optimised-iterator-methods-that-produce-bytes-objects">Addition of optimised iterator methods that produce <code class="docutils literal notranslate"><span class="pre">bytes</span></code> objects</a></li>
</ul>
</li>
<li><a class="reference internal" href="#design-discussion">Design discussion</a><ul>
<li><a class="reference internal" href="#why-not-rely-on-sequence-repetition-to-create-zero-initialised-sequences">Why not rely on sequence repetition to create zero-initialised sequences?</a></li>
<li><a class="reference internal" href="#omitting-the-originally-proposed-builtin-function">Omitting the originally proposed builtin function</a></li>
<li><a class="reference internal" href="#scope-limitation-memoryview">Scope limitation: memoryview</a></li>
</ul>
</li>
<li><a class="reference internal" href="#references">References</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>

            <br />
            <a id="source" href="https://github.com/python/peps/blob/main/pep-0467.txt">Page Source (GitHub)</a>
        </nav>
    </section>
    <script src="../_static/colour_scheme.js"></script>
    <script src="../_static/wrap_tables.js"></script>
</body>
</html>