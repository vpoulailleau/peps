
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="color-scheme" content="light dark" />
    <title>PEP 684 – A Per-Interpreter GIL | peps.python.org</title>
    <link rel="shortcut icon" href="../_static/py.png"/>
    <link rel="canonical" href="https://peps.python.org/pep-0684.html" />
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    <link rel="stylesheet" href="../_static/mq.css" type="text/css" />
    <link rel="stylesheet" href="../_static/dark.css" type="text/css" media="(prefers-color-scheme: dark)" id="css-dark"/>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" media="(prefers-color-scheme: light)" id="pyg" />
    <link rel="stylesheet" href="../_static/pygments_dark.css" type="text/css" media="(prefers-color-scheme: dark)" id="pyg-dark" />
    <link href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
    <meta name="description" content="Python Enhancement Proposals (PEPs)"/>
</head>
<body>
    <section id="pep-page-section">
        <header>
            <h1>Python Enhancement Proposals</h1>
            <ul class="breadcrumbs">
                <li><a href="https://www.python.org/" title="The Python Programming Language">Python</a> &raquo; </li>
                <li><a href="../pep-0000/">PEP Index</a> &raquo; </li>
                <li>PEP 684 – A Per-Interpreter GIL</li>
            </ul>
            <button aria-label="Toggle dark mode" onClick="toggleColourScheme()"></button>
        </header>
        <article>
            <section id="pep-content">
<h1 class="page-title">PEP 684 – A Per-Interpreter GIL</h1>
<dl class="rfc2822 field-list simple">
<dt class="field-odd">PEP</dt>
<dd class="field-odd">684</dd>
<dt class="field-even">Title</dt>
<dd class="field-even">A Per-Interpreter GIL</dd>
<dt class="field-odd">Author</dt>
<dd class="field-odd">Eric Snow &lt;ericsnowcurrently&#32;&#97;t&#32;gmail.com&gt;</dd>
<dt class="field-even">Discussions-To</dt>
<dd class="field-even"><a class="reference external" href="https://mail.python.org/archives/list/python-dev&#64;python.org/thread/CF7B7FMACFYDAHU6NPBEVEY6TOSGICXU/">Python-Dev</a></dd>
<dt class="field-odd">Status</dt>
<dd class="field-odd">Draft</dd>
<dt class="field-even">Type</dt>
<dd class="field-even">Standards Track</dd>
<dt class="field-odd">Created</dt>
<dd class="field-odd">08-Mar-2022</dd>
<dt class="field-even">Python-Version</dt>
<dd class="field-even">3.11</dd>
<dt class="field-odd">Post-History</dt>
<dd class="field-odd"><a class="reference external" href="https://mail.python.org/archives/list/python-dev&#64;python.org/thread/CF7B7FMACFYDAHU6NPBEVEY6TOSGICXU/">08-Mar-2022</a></dd>
<dt class="field-even">Resolution</dt>
<dd class="field-even"><p></p></dd>
</dl>
<hr class="docutils" />
<section id="contents">
<details><summary>Contents</summary><ul class="simple">
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#high-level-summary">High-Level Summary</a><ul>
<li><a class="reference internal" href="#the-gil">The GIL</a></li>
<li><a class="reference internal" href="#cpython-runtime-state">CPython Runtime State</a></li>
<li><a class="reference internal" href="#other-isolation-considerations">Other Isolation Considerations</a></li>
<li><a class="reference internal" href="#depending-on-immortal-objects">Depending on Immortal Objects</a></li>
</ul>
</li>
<li><a class="reference internal" href="#motivation">Motivation</a><ul>
<li><a class="reference internal" href="#indirect-benefits">Indirect Benefits</a></li>
<li><a class="reference internal" href="#existing-use-of-multiple-interpreters">Existing Use of Multiple Interpreters</a></li>
<li><a class="reference internal" href="#pep-554">PEP 554</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rationale">Rationale</a></li>
<li><a class="reference internal" href="#specification">Specification</a><ul>
<li><a class="reference internal" href="#per-interpreter-state">Per-Interpreter State</a></li>
<li><a class="reference internal" href="#c-api">C-API</a></li>
<li><a class="reference internal" href="#restricting-extension-modules">Restricting Extension Modules</a><ul>
<li><a class="reference internal" href="#extension-module-compatibility">Extension Module Compatibility</a></li>
</ul>
</li>
<li><a class="reference internal" href="#documentation">Documentation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#impact">Impact</a><ul>
<li><a class="reference internal" href="#backwards-compatibility">Backwards Compatibility</a><ul>
<li><a class="reference internal" href="#extension-modules">Extension Modules</a></li>
</ul>
</li>
<li><a class="reference internal" href="#extension-module-maintainers">Extension Module Maintainers</a></li>
<li><a class="reference internal" href="#alternate-python-implementations">Alternate Python Implementations</a></li>
<li><a class="reference internal" href="#security-implications">Security Implications</a></li>
<li><a class="reference internal" href="#maintainability">Maintainability</a></li>
<li><a class="reference internal" href="#performance">Performance</a></li>
</ul>
</li>
<li><a class="reference internal" href="#how-to-teach-this">How to Teach This</a></li>
<li><a class="reference internal" href="#reference-implementation">Reference Implementation</a></li>
<li><a class="reference internal" href="#open-issues">Open Issues</a></li>
<li><a class="reference internal" href="#deferred-functionality">Deferred Functionality</a></li>
<li><a class="reference internal" href="#rejected-ideas">Rejected Ideas</a></li>
<li><a class="reference internal" href="#extra-context">Extra Context</a><ul>
<li><a class="reference internal" href="#sharing-global-objects">Sharing Global Objects</a><ul>
<li><a class="reference internal" href="#objects-exposed-in-the-c-api">Objects Exposed in the C-API</a></li>
</ul>
</li>
<li><a class="reference internal" href="#consolidating-runtime-global-state">Consolidating Runtime Global State</a><ul>
<li><a class="reference internal" href="#benefits-to-consolidation">Benefits to Consolidation</a></li>
<li><a class="reference internal" href="#scale-of-work">Scale of Work</a></li>
<li><a class="reference internal" href="#state-to-be-moved">State To Be Moved</a></li>
<li><a class="reference internal" href="#already-completed-work">Already Completed Work</a></li>
<li><a class="reference internal" href="#tooling">Tooling</a></li>
<li><a class="reference internal" href="#global-objects">Global Objects</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#references">References</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>
</details></section>
<section id="abstract">
<h2><a class="toc-backref" href="#abstract">Abstract</a></h2>
<p>Since Python 1.5 (1997), CPython users can run multiple interpreters
in the same process.  However, interpreters in the same process
have always shared a significant
amount of global state.  This is a source of bugs, with a growing
impact as more and more people use the feature.  Furthermore,
sufficient isolation would facilitate true multi-core parallelism,
where interpreters no longer share the GIL.  The changes outlined in
this proposal will result in that level of interpreter isolation.</p>
</section>
<section id="high-level-summary">
<h2><a class="toc-backref" href="#high-level-summary">High-Level Summary</a></h2>
<p>At a high level, this proposal changes CPython in the following ways:</p>
<ul class="simple">
<li>stops sharing the GIL between interpreters, given sufficient isolation</li>
<li>adds several new interpreter config options for isolation settings</li>
<li>adds some public C-API for fine-grained control when creating interpreters</li>
<li>keeps incompatible extensions from causing problems</li>
</ul>
<section id="the-gil">
<h3><a class="toc-backref" href="#the-gil">The GIL</a></h3>
<p>The GIL protects concurrent access to most of CPython’s runtime state.
So all that GIL-protected global state must move to each interpreter
before the GIL can.</p>
<p>(In a handful of cases, other mechanisms can be used to ensure
thread-safe sharing instead, such as locks or “immortal” objects.)</p>
</section>
<section id="cpython-runtime-state">
<h3><a class="toc-backref" href="#cpython-runtime-state">CPython Runtime State</a></h3>
<p>Properly isolating interpreters requires that most of CPython’s
runtime state be stored in the <code class="docutils literal notranslate"><span class="pre">PyInterpreterState</span></code> struct.  Currently,
only a portion of it is; the rest is found either in global variables
or in <code class="docutils literal notranslate"><span class="pre">_PyRuntimeState</span></code>.  Most of that will have to be moved.</p>
<p>This directly coincides with an ongoing effort (of many years) to greatly
reduce internal use of C global variables and consolidate the runtime
state into <code class="docutils literal notranslate"><span class="pre">_PyRuntimeState</span></code> and <code class="docutils literal notranslate"><span class="pre">PyInterpreterState</span></code>.
(See <a class="reference internal" href="#consolidating-runtime-global-state">Consolidating Runtime Global State</a> below.)  That project has
<a class="reference internal" href="#benefits-to-consolidation">significant merit on its own</a>
and has faced little controversy.  So, while a per-interpreter GIL
relies on the completion of that effort, that project should not be
considered a part of this proposal–only a dependency.</p>
</section>
<section id="other-isolation-considerations">
<h3><a class="toc-backref" href="#other-isolation-considerations">Other Isolation Considerations</a></h3>
<p>CPython’s interpreters must be strictly isolated from each other, with
few exceptions.  To a large extent they already are.  Each interpreter
has its own copy of all modules, classes, functions, and variables.
The CPython C-API docs <a class="reference external" href="https://docs.python.org/3/c-api/init.html#bugs-and-caveats">explain further</a>.</p>
<p>However, aside from what has already been mentioned (e.g. the GIL),
there are a couple of ways in which interpreters still share some state.</p>
<p>First of all, some process-global resources (e.g. memory,
file descriptors, environment variables) are shared.  There are no
plans to change this.</p>
<p>Second, some isolation is faulty due to bugs or implementations that
did not take multiple interpreters into account.  This includes
CPython’s runtime and the stdlib, as well as extension modules that
rely on global variables.  Bugs should be opened in these cases,
as some already have been.</p>
</section>
<section id="depending-on-immortal-objects">
<h3><a class="toc-backref" href="#depending-on-immortal-objects">Depending on Immortal Objects</a></h3>
<p><a class="pep reference internal" href="../pep-0683" title="PEP 683 – Immortal Objects, Using a Fixed Refcount">PEP 683</a> introduces immortal objects as a CPython-internal feature.
With immortal objects, we can share any otherwise immutable global
objects between all interpreters.  Consequently, this PEP does not
need to address how to deal with the various objects
<a class="reference internal" href="#capi-objects">exposed in the public C-API</a>.
It also simplifies the question of what to do about the builtin
static types.  (See <a class="reference internal" href="#global-objects">Global Objects</a> below.)</p>
<p>Both issues have alternate solutions, but everything is simpler with
immortal objects.  If PEP 683 is not accepted then this one will be
updated with the alternatives.  This lets us reduce noise in this
proposal.</p>
</section>
</section>
<section id="motivation">
<h2><a class="toc-backref" href="#motivation">Motivation</a></h2>
<p>The fundamental problem we’re solving here is a lack of true multi-core
parallelism (for Python code) in the CPython runtime.  The GIL is the
cause.  While it usually isn’t a problem in practice, at the very least
it makes Python’s multi-core story murky, which makes the GIL
a consistent distraction.</p>
<p>Isolated interpreters are also an effective mechanism to support
certain concurrency models.  <a class="pep reference internal" href="../pep-0554" title="PEP 554 – Multiple Interpreters in the Stdlib">PEP 554</a> discusses this in more detail.</p>
<section id="indirect-benefits">
<h3><a class="toc-backref" href="#indirect-benefits">Indirect Benefits</a></h3>
<p>Most of the effort needed for a per-interpreter GIL has benefits that
make those tasks worth doing anyway:</p>
<ul class="simple">
<li>makes multiple-interpreter behavior more reliable</li>
<li>has led to fixes for long-standing runtime bugs that otherwise
hadn’t been prioritized</li>
<li>has been exposing (and inspiring fixes for) previously unknown runtime bugs</li>
<li>has driven cleaner runtime initialization (<a class="pep reference internal" href="../pep-0432" title="PEP 432 – Restructuring the CPython startup sequence">PEP 432</a>, <a class="pep reference internal" href="../pep-0587" title="PEP 587 – Python Initialization Configuration">PEP 587</a>)</li>
<li>has driven cleaner and more complete runtime finalization</li>
<li>led to structural layering of the C-API (e.g. <code class="docutils literal notranslate"><span class="pre">Include/internal</span></code>)</li>
<li>also see <a class="reference internal" href="#benefits-to-consolidation">Benefits to Consolidation</a> below</li>
</ul>
<p>Furthermore, much of that work benefits other CPython-related projects:</p>
<ul class="simple">
<li>performance improvements (“faster-cpython”)</li>
<li>pre-fork application deployment (e.g. Instagram)</li>
<li>extension module isolation (see <a class="pep reference internal" href="../pep-0630" title="PEP 630 – Isolating Extension Modules">PEP 630</a>, etc.)</li>
<li>embedding CPython</li>
</ul>
</section>
<section id="existing-use-of-multiple-interpreters">
<h3><a class="toc-backref" href="#existing-use-of-multiple-interpreters">Existing Use of Multiple Interpreters</a></h3>
<p>The C-API for multiple interpreters has been used for many years.
However, until relatively recently the feature wasn’t widely known,
nor extensively used (with the exception of mod_wsgi).</p>
<p>In the last few years use of multiple interpreters has been increasing.
Here are some of the public projects using the feature currently:</p>
<ul class="simple">
<li><a class="reference external" href="https://github.com/GrahamDumpleton/mod_wsgi">mod_wsgi</a></li>
<li><a class="reference external" href="https://github.com/ceph/ceph/pull/14971">OpenStack Ceph</a></li>
<li><a class="reference external" href="https://github.com/ninia/jep">JEP</a></li>
<li><a class="reference external" href="https://github.com/xbmc/xbmc">Kodi</a></li>
</ul>
<p>Note that, with <a class="pep reference internal" href="../pep-0554" title="PEP 554 – Multiple Interpreters in the Stdlib">PEP 554</a>, multiple interpreter usage would likely
grow significantly (via Python code rather than the C-API).</p>
</section>
<section id="pep-554">
<h3><a class="toc-backref" href="#pep-554">PEP 554</a></h3>
<p><a class="pep reference internal" href="../pep-0554" title="PEP 554 – Multiple Interpreters in the Stdlib">PEP 554</a> is strictly about providing a minimal stdlib module
to give users access to multiple interpreters from Python code.
In fact, it specifically avoids proposing any changes related to
the GIL.  Consider, however, that users of that module would benefit
from a per-interpreter GIL, which makes PEP 554 more appealing.</p>
</section>
</section>
<section id="rationale">
<h2><a class="toc-backref" href="#rationale">Rationale</a></h2>
<p>During initial investigations in 2014, a variety of possible solutions
for multi-core Python were explored, but each had its drawbacks
without simple solutions:</p>
<ul class="simple">
<li>the existing practice of releasing the GIL in extension modules
* doesn’t help with Python code</li>
<li>other Python implementations (e.g. Jython, IronPython)
* CPython dominates the community</li>
<li>remove the GIL (e.g. gilectomy, “no-gil”)
* too much technical risk (at the time)</li>
<li>Trent Nelson’s “PyParallel” project
* incomplete; Windows-only at the time</li>
<li><code class="docutils literal notranslate"><span class="pre">multiprocessing</span></code><ul>
<li>too much work to make it effective enough;
high penalties in some situations (at large scale, Windows)</li>
</ul>
</li>
<li>other parallelism tools (e.g. dask, ray, MPI)
* not a fit for the stdlib</li>
<li>give up on multi-core (e.g. async, do nothing)
* this can only end in tears</li>
</ul>
<p>Even in 2014, it was fairly clear that a solution using isolated
interpreters did not have a high level of technical risk and that
most of the work was worth doing anyway.
(The downside was the volume of work to be done.)</p>
</section>
<section id="specification">
<h2><a class="toc-backref" href="#specification">Specification</a></h2>
<p>As <a class="reference internal" href="#high-level-summary">summarized above</a>, this proposal involves the
following changes, in the order they must happen:</p>
<ol class="arabic simple">
<li><a class="reference internal" href="#consolidating-runtime-global-state">consolidate global runtime state</a>
(including objects) into <code class="docutils literal notranslate"><span class="pre">_PyRuntimeState</span></code></li>
<li>move nearly all of the state down into <code class="docutils literal notranslate"><span class="pre">PyInterpreterState</span></code></li>
<li>finally, move the GIL down into <code class="docutils literal notranslate"><span class="pre">PyInterpreterState</span></code></li>
<li>everything else
* add to the public C-API
* implement restrictions in <code class="docutils literal notranslate"><span class="pre">ExtensionFileLoader</span></code><ul class="simple">
<li>work with popular extension maintainers to help
with multi-interpreter support</li>
</ul>
</li>
</ol>
<section id="per-interpreter-state">
<h3><a class="toc-backref" href="#per-interpreter-state">Per-Interpreter State</a></h3>
<p>The following runtime state will be moved to <code class="docutils literal notranslate"><span class="pre">PyInterpreterState</span></code>:</p>
<ul class="simple">
<li>all global objects that are not safely shareable (fully immutable)</li>
<li>the GIL</li>
<li>mutable, currently protected by the GIL</li>
<li>mutable, currently protected by some other per-interpreter lock</li>
<li>mutable, may be used independently in different interpreters</li>
<li>all other mutable (or effectively mutable) state
not otherwise excluded below</li>
</ul>
<p>Furthermore, a number of parts of the global state have already been
moved to the interpreter, such as GC, warnings, and atexit hooks.</p>
<p>The following state will not be moved:</p>
<ul class="simple">
<li>global objects that are safely shareable, if any</li>
<li>immutable, often <code class="docutils literal notranslate"><span class="pre">const</span></code></li>
<li>treated as immutable</li>
<li>related to CPython’s <code class="docutils literal notranslate"><span class="pre">main()</span></code> execution</li>
<li>related to the REPL</li>
<li>set during runtime init, then treated as immutable</li>
<li>mutable, protected by some global lock</li>
<li>mutable, atomic</li>
</ul>
<p>Note that currently the allocators (see <code class="docutils literal notranslate"><span class="pre">Objects/obmalloc.c</span></code>) are shared
between all interpreters, protected by the GIL.  They will need to move
to each interpreter (or a global lock will be needed).  This is the
highest risk part of the work to isolate interpreters and may require
more than just moving fields down from <code class="docutils literal notranslate"><span class="pre">_PyRuntimeState</span></code>.  Some of
the complexity is reduced if CPython switches to a thread-safe
allocator like mimalloc.</p>
</section>
<section id="c-api">
<span id="proposed-capi"></span><h3><a class="toc-backref" href="#c-api">C-API</a></h3>
<p>The following private API will be made public:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">_PyInterpreterConfig</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">_Py_NewInterpreter()</span></code> (as <code class="docutils literal notranslate"><span class="pre">Py_NewInterpreterEx()</span></code>)</li>
</ul>
<p>The following fields will be added to <code class="docutils literal notranslate"><span class="pre">PyInterpreterConfig</span></code>:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">own_gil</span></code> - (bool) create a new interpreter lock
(instead of sharing with the main interpreter)</li>
<li><code class="docutils literal notranslate"><span class="pre">strict_extensions</span></code> - fail import in this interpreter for
incompatible extensions (see <a class="reference internal" href="#restricting-extension-modules">Restricting Extension Modules</a>)</li>
</ul>
</section>
<section id="restricting-extension-modules">
<h3><a class="toc-backref" href="#restricting-extension-modules">Restricting Extension Modules</a></h3>
<p>Extension modules have many of the same problems as the runtime when
state is stored in global variables.  <a class="pep reference internal" href="../pep-0630" title="PEP 630 – Isolating Extension Modules">PEP 630</a> covers all the details
of what extensions must do to support isolation, and thus safely run in
multiple interpreters at once.  This includes dealing with their globals.</p>
<p>Extension modules that do not implement isolation will only run in
the main interpreter.  In all other interpreters, the import will
raise <code class="docutils literal notranslate"><span class="pre">ImportError</span></code>.  This will be done through
<code class="docutils literal notranslate"><span class="pre">importlib._bootstrap_external.ExtensionFileLoader</span></code>.</p>
<p>We will work with popular extensions to help them support use in
multiple interpreters.  This may involve adding to CPython’s public C-API,
which we will address on a case-by-case basis.</p>
<section id="extension-module-compatibility">
<h4><a class="toc-backref" href="#extension-module-compatibility">Extension Module Compatibility</a></h4>
<p>As noted in <a class="reference internal" href="#extension-modules">Extension Modules</a>, many extensions work fine in multiple
interpreters without needing any changes.  The import system will still
fail if such a module doesn’t explicitly indicate support.  At first,
not many extension modules will, so this is a potential source
of frustration.</p>
<p>We will address this by adding a context manager to temporarily disable
the check on multiple interpreter support:
<code class="docutils literal notranslate"><span class="pre">importlib.util.allow_all_extensions()</span></code>.</p>
</section>
</section>
<section id="documentation">
<h3><a class="toc-backref" href="#documentation">Documentation</a></h3>
<p>The “Sub-interpreter support” section of <code class="docutils literal notranslate"><span class="pre">Doc/c-api/init.rst</span></code> will be
updated with the added API.</p>
</section>
</section>
<section id="impact">
<h2><a class="toc-backref" href="#impact">Impact</a></h2>
<section id="backwards-compatibility">
<h3><a class="toc-backref" href="#backwards-compatibility">Backwards Compatibility</a></h3>
<p>No behavior or APIs are intended to change due to this proposal,
with one exception noted in <a class="reference internal" href="#extension-modules">the next section</a>.
The existing C-API for managing interpreters will preserve its current
behavior, with new behavior exposed through new API.  No other API
or runtime behavior is meant to change, including compatibility with
the stable ABI.</p>
<p>See <a class="reference internal" href="#objects-exposed-in-the-c-api">Objects Exposed in the C-API</a> below for related discussion.</p>
<section id="extension-modules">
<h4><a class="toc-backref" href="#extension-modules">Extension Modules</a></h4>
<p>Currently the most common usage of Python, by far, is with the main
interpreter running by itself.  This proposal has zero impact on
extension modules in that scenario.  Likewise, for better or worse,
there is no change in behavior under multiple interpreters created
using the existing <code class="docutils literal notranslate"><span class="pre">Py_NewInterpreter()</span></code>.</p>
<p>Keep in mind that some extensions already break when used in multiple
interpreters, due to keeping module state in global variables.  They
may crash or, worse, experience inconsistent behavior.  That was part
of the motivation for <a class="pep reference internal" href="../pep-0630" title="PEP 630 – Isolating Extension Modules">PEP 630</a> and friends, so this is not a new
situation nor a consequence of this proposal.</p>
<p>In contrast, when the <a class="reference internal" href="#proposed-capi">proposed API</a> is used to
create multiple interpreters, the default behavior will change for
some extensions.  In that case, importing an extension will fail
(outside the main interpreter) if it doesn’t indicate support for
multiple interpreters.  For extensions that already break in
multiple interpreters, this will be an improvement.</p>
<p>Now we get to the break in compatibility mentioned above.  Some
extensions are safe under multiple interpreters, even though they
haven’t indicated that.  Unfortunately, there is no reliable way for
the import system to infer that such an extension is safe, so
importing them will still fail.  This case is addressed in
<a class="reference internal" href="#extension-module-compatibility">Extension Module Compatibility</a> below.</p>
</section>
</section>
<section id="extension-module-maintainers">
<h3><a class="toc-backref" href="#extension-module-maintainers">Extension Module Maintainers</a></h3>
<p>One related consideration is that a per-interpreter GIL will likely
drive increased use of multiple interpreters, particularly if <a class="pep reference internal" href="../pep-0554" title="PEP 554 – Multiple Interpreters in the Stdlib">PEP 554</a>
is accepted.  Some maintainers of large extension modules have expressed
concern about the increased burden they anticipate due to increased
use of multiple interpreters.</p>
<p>Specifically, enabling support for multiple interpreters will require
substantial work for some extension modules.  To add that support,
the maintainer(s) of such a module (often volunteers) would have to
set aside their normal priorities and interests to focus on
compatibility (see <a class="pep reference internal" href="../pep-0630" title="PEP 630 – Isolating Extension Modules">PEP 630</a>).</p>
<p>Of course, extension maintainers are free to not add support for use
in multiple interpreters.  However, users will increasingly demand
such support, especially if the feature grows
in popularity.</p>
<p>Either way, the situation can be stressful for maintainers of such
extensions, particularly when they are doing the work in their spare
time.  The concerns they have expressed are understandable, and we address
the partial solution in <a class="reference internal" href="#restricting-extension-modules">Restricting Extension Modules</a> below.</p>
</section>
<section id="alternate-python-implementations">
<h3><a class="toc-backref" href="#alternate-python-implementations">Alternate Python Implementations</a></h3>
<p>Other Python implementation are not required to provide support for
multiple interpreters in the same process (though some do already).</p>
</section>
<section id="security-implications">
<h3><a class="toc-backref" href="#security-implications">Security Implications</a></h3>
<p>There is no known impact to security with this proposal.</p>
</section>
<section id="maintainability">
<h3><a class="toc-backref" href="#maintainability">Maintainability</a></h3>
<p>On the one hand, this proposal has already motivated a number of
improvements that make CPython <em>more</em> maintainable.  That is expected
to continue.  On the other hand, the underlying work has already
exposed various pre-existing defects in the runtime that have had
to be fixed.  That is also expected to continue as multiple interpreters
receive more use.  Otherwise, there shouldn’t be a significant impact
on maintainability, so the net effect should be positive.</p>
</section>
<section id="performance">
<h3><a class="toc-backref" href="#performance">Performance</a></h3>
<p>The work to consolidate globals has already provided a number of
improvements to CPython’s performance, both speeding it up and using
less memory, and this should continue. Performance benefits to a
per-interpreter GIL have not been explored.  At the very least, it is
not expected to make CPython slower (as long as interpreters are
sufficiently isolated).</p>
</section>
</section>
<section id="how-to-teach-this">
<h2><a class="toc-backref" href="#how-to-teach-this">How to Teach This</a></h2>
<p>This is an advanced feature for users of the C-API.  There is no
expectation that this will be taught.</p>
<p>That said, if it were taught then it would boil down to the following:</p>
<blockquote>
<div>In addition to Py_NewInterpreter(), you can use Py_NewInterpreterEx()
to create an interpreter.  The config you pass it indicates how you
want that interpreter to behave.</div></blockquote>
</section>
<section id="reference-implementation">
<h2><a class="toc-backref" href="#reference-implementation">Reference Implementation</a></h2>
<p>&lt;TBD&gt;</p>
</section>
<section id="open-issues">
<h2><a class="toc-backref" href="#open-issues">Open Issues</a></h2>
<ul class="simple">
<li>What are the risks/hurdles involved with moving the allocators?</li>
<li>Is <code class="docutils literal notranslate"><span class="pre">allow_all_extensions</span></code> the best name for the context manager?</li>
</ul>
</section>
<section id="deferred-functionality">
<h2><a class="toc-backref" href="#deferred-functionality">Deferred Functionality</a></h2>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">PyInterpreterConfig</span></code> option to always run the interpreter in a new thread</li>
<li><code class="docutils literal notranslate"><span class="pre">PyInterpreterConfig</span></code> option to assign a “main” thread to the interpreter
and only run in that thread</li>
</ul>
</section>
<section id="rejected-ideas">
<h2><a class="toc-backref" href="#rejected-ideas">Rejected Ideas</a></h2>
<p>&lt;TBD&gt;</p>
</section>
<section id="extra-context">
<h2><a class="toc-backref" href="#extra-context">Extra Context</a></h2>
<section id="sharing-global-objects">
<h3><a class="toc-backref" href="#sharing-global-objects">Sharing Global Objects</a></h3>
<p>We are sharing some global objects between interpreters.
This is an implementation detail and relates more to
<a class="reference external" href="ConsolidatingRuntimeGlobalState">globals consolidation</a>
than to this proposal, but it is a significant enough detail
to explain here.</p>
<p>The alternative is to share no objects between interpreters, ever.
To accomplish that, we’d have to sort out the fate of all our static
types, as well as deal with compatibility issues for the many objects
<a class="reference internal" href="#capi-objects">exposed in the public C-API</a>.</p>
<p>That approach introduces a meaningful amount of extra complexity
and higher risk, though prototyping has demonstrated valid solutions.
Also, it would likely result in a performance penalty.</p>
<p><a class="reference internal" href="#depending-on-immortal-objects">Immortal objects</a> allow us to
share the otherwise immutable global objects.  That way we avoid
the extra costs.</p>
<section id="objects-exposed-in-the-c-api">
<span id="capi-objects"></span><h4><a class="toc-backref" href="#objects-exposed-in-the-c-api">Objects Exposed in the C-API</a></h4>
<p>The C-API (including the limited API) exposes all the builtin types,
including the builtin exceptions, as well as the builtin singletons.
The exceptions are exposed as <code class="docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*</span></code> but the rest are exposed
as the static values rather than pointers.  This was one of the few
non-trivial problems we had to solve for per-interpreter GIL.</p>
<p>With immortal objects this is a non-issue.</p>
</section>
</section>
<section id="consolidating-runtime-global-state">
<h3><a class="toc-backref" href="#consolidating-runtime-global-state">Consolidating Runtime Global State</a></h3>
<p>As noted in <a class="reference internal" href="#cpython-runtime-state">CPython Runtime State</a> above, there is an active effort
(separate from this PEP) to consolidate CPython’s global state into the
<code class="docutils literal notranslate"><span class="pre">_PyRuntimeState</span></code> struct.  Nearly all the work involves moving that
state from global variables.  The project is particularly relevant to
this proposal, so below is some extra detail.</p>
<section id="benefits-to-consolidation">
<h4><a class="toc-backref" href="#benefits-to-consolidation">Benefits to Consolidation</a></h4>
<p>Consolidating the globals has a variety of benefits:</p>
<ul class="simple">
<li>greatly reduces the number of C globals (best practice for C code)</li>
<li>the move draws attention to runtime state that is unstable or broken</li>
<li>encourages more consistency in how runtime state is used</li>
<li>makes multiple-interpreter behavior more reliable</li>
<li>leads to fixes for long-standing runtime bugs that otherwise
haven’t been prioritized</li>
<li>exposes (and inspires fixes for) previously unknown runtime bugs</li>
<li>facilitates cleaner runtime initialization and finalization</li>
<li>makes it easier to discover/identify CPython’s runtime state</li>
<li>makes it easier to statically allocate runtime state in a consistent way</li>
<li>better memory locality for runtime state</li>
<li>structural layering of the C-API (e.g. <code class="docutils literal notranslate"><span class="pre">Include/internal</span></code>)</li>
</ul>
<p>Furthermore, much of that work benefits other CPython-related projects:</p>
<ul class="simple">
<li>performance improvements (“faster-cpython”)</li>
<li>pre-fork application deployment (e.g. Instagram)</li>
<li>extension module isolation (see <a class="pep reference internal" href="../pep-0630" title="PEP 630 – Isolating Extension Modules">PEP 630</a>, etc.)</li>
<li>embedding CPython</li>
</ul>
</section>
<section id="scale-of-work">
<h4><a class="toc-backref" href="#scale-of-work">Scale of Work</a></h4>
<p>The number of global variables to be moved is large enough to matter,
but most are Python objects that can be dealt with in large groups
(like <code class="docutils literal notranslate"><span class="pre">Py_IDENTIFIER</span></code>).  In nearly all cases, moving these globals
to the interpreter is highly mechanical.  That doesn’t require
cleverness but instead requires someone to put in the time.</p>
</section>
<section id="state-to-be-moved">
<h4><a class="toc-backref" href="#state-to-be-moved">State To Be Moved</a></h4>
<p>The remaining global variables can be categorized as follows:</p>
<ul class="simple">
<li>global objects
* static types (incl. exception types)
* non-static types (incl. heap types, structseq types)
* singletons (static)
* singletons (initialized once)
* cached objects</li>
<li>non-objects
* will not (or unlikely to) change after init
* only used in the main thread
* initialized lazily
* pre-allocated buffers
* state</li>
</ul>
<p>Those globals are spread between the core runtime, the builtin modules,
and the stdlib extension modules.</p>
<p>For a breakdown of the remaining globals, run:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./python Tools/c-analyzer/table-file.py Tools/c-analyzer/cpython/globals-to-fix.tsv
</pre></div>
</div>
</section>
<section id="already-completed-work">
<h4><a class="toc-backref" href="#already-completed-work">Already Completed Work</a></h4>
<p>As mentioned, this work has been going on for many years.  Here are some
of the things that have already been done:</p>
<ul class="simple">
<li>cleanup of runtime initialization (see <a class="pep reference internal" href="../pep-0432" title="PEP 432 – Restructuring the CPython startup sequence">PEP 432</a> / <a class="pep reference internal" href="../pep-0587" title="PEP 587 – Python Initialization Configuration">PEP 587</a>)</li>
<li>extension module isolation machinery (see <a class="pep reference internal" href="../pep-0384" title="PEP 384 – Defining a Stable ABI">PEP 384</a> / <a class="pep reference internal" href="../pep-3121" title="PEP 3121 – Extension Module Initialization and Finalization">PEP 3121</a> / <a class="pep reference internal" href="../pep-0489" title="PEP 489 – Multi-phase extension module initialization">PEP 489</a>)</li>
<li>isolation for many builtin modules</li>
<li>isolation for many stdlib extension modules</li>
<li>addition of <code class="docutils literal notranslate"><span class="pre">_PyRuntimeState</span></code></li>
<li>no more <code class="docutils literal notranslate"><span class="pre">_Py_IDENTIFIER()</span></code></li>
<li>statically allocated:<ul>
<li>empty string</li>
<li>string literals</li>
<li>identifiers</li>
<li>latin-1 strings</li>
<li>length-1 bytes</li>
<li>empty tuple</li>
</ul>
</li>
</ul>
</section>
<section id="tooling">
<h4><a class="toc-backref" href="#tooling">Tooling</a></h4>
<p>As already indicated, there are several tools to help identify the
globals and reason about them.</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">Tools/c-analyzer/cpython/globals-to-fix.tsv</span></code> - the list of remaining globals</li>
<li><code class="docutils literal notranslate"><span class="pre">Tools/c-analyzer/c-analyzer.py</span></code>
* <code class="docutils literal notranslate"><span class="pre">analyze</span></code> - identify all the globals
* <code class="docutils literal notranslate"><span class="pre">check</span></code> - fail if there are any unsupported globals that aren’t ignored</li>
<li><code class="docutils literal notranslate"><span class="pre">Tools/c-analyzer/table-file.py</span></code> - summarize the known globals</li>
</ul>
<p>Also, the check for unsupported globals is incorporated into CI so that
no new globals are accidentally added.</p>
</section>
<section id="global-objects">
<h4><a class="toc-backref" href="#global-objects">Global Objects</a></h4>
<p>Global objects that are safe to be shared (without a GIL) between
interpreters can stay on <code class="docutils literal notranslate"><span class="pre">_PyRuntimeState</span></code>.  Not only must the object
be effectively immutable (e.g. singletons, strings), but not even the
refcount can change for it to be safe.  Immortality (<a class="pep reference internal" href="../pep-0683" title="PEP 683 – Immortal Objects, Using a Fixed Refcount">PEP 683</a>)
provides that.  (The alternative is that no objects are shared, which
adds significant complexity to the solution, particularly for the
objects <a class="reference internal" href="#capi-objects">exposed in the public C-API</a>.)</p>
<p>Builtin static types are a special case of global objects that will be
shared.  They are effectively immutable except for one part:
<code class="docutils literal notranslate"><span class="pre">__subclasses__</span></code> (AKA <code class="docutils literal notranslate"><span class="pre">tp_subclasses</span></code>).  We expect that nothing
else on a builtin type will change, even the content
of <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> (AKA <code class="docutils literal notranslate"><span class="pre">tp_dict</span></code>).</p>
<p><code class="docutils literal notranslate"><span class="pre">__subclasses__</span></code> for the builtin types will be dealt with by making
it a getter that does a lookup on the current <code class="docutils literal notranslate"><span class="pre">PyInterpreterState</span></code>
for that type.</p>
</section>
</section>
</section>
<section id="references">
<h2><a class="toc-backref" href="#references">References</a></h2>
<p>Related:</p>
<ul class="simple">
<li><a class="pep reference internal" href="../pep-0384" title="PEP 384 – Defining a Stable ABI">PEP 384</a></li>
<li><a class="pep reference internal" href="../pep-0432" title="PEP 432 – Restructuring the CPython startup sequence">PEP 432</a></li>
<li><a class="pep reference internal" href="../pep-0489" title="PEP 489 – Multi-phase extension module initialization">PEP 489</a></li>
<li><a class="pep reference internal" href="../pep-0554" title="PEP 554 – Multiple Interpreters in the Stdlib">PEP 554</a></li>
<li><a class="pep reference internal" href="../pep-0573" title="PEP 573 – Module State Access from C Extension Methods">PEP 573</a></li>
<li><a class="pep reference internal" href="../pep-0587" title="PEP 587 – Python Initialization Configuration">PEP 587</a></li>
<li><a class="pep reference internal" href="../pep-0630" title="PEP 630 – Isolating Extension Modules">PEP 630</a></li>
<li><a class="pep reference internal" href="../pep-0683" title="PEP 683 – Immortal Objects, Using a Fixed Refcount">PEP 683</a></li>
<li><a class="pep reference internal" href="../pep-3121" title="PEP 3121 – Extension Module Initialization and Finalization">PEP 3121</a></li>
</ul>
</section>
<section id="copyright">
<h2><a class="toc-backref" href="#copyright">Copyright</a></h2>
<p>This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.</p>
</section>
</section>
<hr class="docutils" />
<p>Source: <a class="reference external" href="https://github.com/python/peps/blob/main/pep-0684.rst">https://github.com/python/peps/blob/main/pep-0684.rst</a></p>
<p>Last modified: <a class="reference external" href="https://github.com/python/peps/commits/main/pep-0684.rst">2022-03-09 16:08:07 GMT</a></p>

        </article>
        <nav id="pep-sidebar">
            <h2>Contents</h2>
            <p id="toc-title">PEP 684 – A Per-Interpreter GIL</p>
            <ul>
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#high-level-summary">High-Level Summary</a><ul>
<li><a class="reference internal" href="#the-gil">The GIL</a></li>
<li><a class="reference internal" href="#cpython-runtime-state">CPython Runtime State</a></li>
<li><a class="reference internal" href="#other-isolation-considerations">Other Isolation Considerations</a></li>
<li><a class="reference internal" href="#depending-on-immortal-objects">Depending on Immortal Objects</a></li>
</ul>
</li>
<li><a class="reference internal" href="#motivation">Motivation</a><ul>
<li><a class="reference internal" href="#indirect-benefits">Indirect Benefits</a></li>
<li><a class="reference internal" href="#existing-use-of-multiple-interpreters">Existing Use of Multiple Interpreters</a></li>
<li><a class="reference internal" href="#pep-554">PEP 554</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rationale">Rationale</a></li>
<li><a class="reference internal" href="#specification">Specification</a><ul>
<li><a class="reference internal" href="#per-interpreter-state">Per-Interpreter State</a></li>
<li><a class="reference internal" href="#c-api">C-API</a></li>
<li><a class="reference internal" href="#restricting-extension-modules">Restricting Extension Modules</a><ul>
<li><a class="reference internal" href="#extension-module-compatibility">Extension Module Compatibility</a></li>
</ul>
</li>
<li><a class="reference internal" href="#documentation">Documentation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#impact">Impact</a><ul>
<li><a class="reference internal" href="#backwards-compatibility">Backwards Compatibility</a><ul>
<li><a class="reference internal" href="#extension-modules">Extension Modules</a></li>
</ul>
</li>
<li><a class="reference internal" href="#extension-module-maintainers">Extension Module Maintainers</a></li>
<li><a class="reference internal" href="#alternate-python-implementations">Alternate Python Implementations</a></li>
<li><a class="reference internal" href="#security-implications">Security Implications</a></li>
<li><a class="reference internal" href="#maintainability">Maintainability</a></li>
<li><a class="reference internal" href="#performance">Performance</a></li>
</ul>
</li>
<li><a class="reference internal" href="#how-to-teach-this">How to Teach This</a></li>
<li><a class="reference internal" href="#reference-implementation">Reference Implementation</a></li>
<li><a class="reference internal" href="#open-issues">Open Issues</a></li>
<li><a class="reference internal" href="#deferred-functionality">Deferred Functionality</a></li>
<li><a class="reference internal" href="#rejected-ideas">Rejected Ideas</a></li>
<li><a class="reference internal" href="#extra-context">Extra Context</a><ul>
<li><a class="reference internal" href="#sharing-global-objects">Sharing Global Objects</a><ul>
<li><a class="reference internal" href="#objects-exposed-in-the-c-api">Objects Exposed in the C-API</a></li>
</ul>
</li>
<li><a class="reference internal" href="#consolidating-runtime-global-state">Consolidating Runtime Global State</a><ul>
<li><a class="reference internal" href="#benefits-to-consolidation">Benefits to Consolidation</a></li>
<li><a class="reference internal" href="#scale-of-work">Scale of Work</a></li>
<li><a class="reference internal" href="#state-to-be-moved">State To Be Moved</a></li>
<li><a class="reference internal" href="#already-completed-work">Already Completed Work</a></li>
<li><a class="reference internal" href="#tooling">Tooling</a></li>
<li><a class="reference internal" href="#global-objects">Global Objects</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#references">References</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>

            <br />
            <a id="source" href="https://github.com/python/peps/blob/main/pep-0684.rst">Page Source (GitHub)</a>
        </nav>
    </section>
    <script src="../_static/colour_scheme.js"></script>
    <script src="../_static/wrap_tables.js"></script>
</body>
</html>